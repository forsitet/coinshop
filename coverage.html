
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">coin/cmd/app/config/config.go (0.0%)</option>
				
				<option value="file1">coin/cmd/app/main.go (0.0%)</option>
				
				<option value="file2">coin/internal/api/http/coin.go (33.1%)</option>
				
				<option value="file3">coin/internal/api/http/middleware/auth.go (53.8%)</option>
				
				<option value="file4">coin/internal/auth/jwt/jwt.go (84.6%)</option>
				
				<option value="file5">coin/internal/database/postgres/coin.go (0.0%)</option>
				
				<option value="file6">coin/internal/database/postgres/init.go (0.0%)</option>
				
				<option value="file7">coin/internal/database/redis/item.go (0.0%)</option>
				
				<option value="file8">coin/internal/repository/coin_repository.go (0.0%)</option>
				
				<option value="file9">coin/internal/repository/mocks/coin.go (96.3%)</option>
				
				<option value="file10">coin/service/coin.go (63.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "flag"
        "log"
        "os"

        "github.com/ilyakaznacheev/cleanenv"
)

type AppFlags struct {
        ConfigPath string
}

type RedisConfig struct {
        Addres string `yaml:"address"`
}

type BDConfig struct {
        Host     string `yaml:"host"`
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        Port     string `yaml:"port"`
}

type HTTPConfig struct {
        Address string `yaml:"address"`
}

type AppConfig struct {
        BD    BDConfig    `yaml:"bd"`
        HTTP  HTTPConfig  `yaml:"http"`
        Redis RedisConfig `yaml:"redis"`
}

func ParseFlags() AppFlags <span class="cov0" title="0">{
        configPath := flag.String("config", "", "Path to config")
        flag.Parse()
        return AppFlags{
                ConfigPath: *configPath,
        }
}</span>

func MustLoad(cfgPath string, cfg any) <span class="cov0" title="0">{
        if cfgPath == "" </span><span class="cov0" title="0">{
                log.Fatal("Config path is not set")
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(cfgPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Fatalf("config file does not exist by this path %s", cfgPath)
        }</span>

        <span class="cov0" title="0">if err := cleanenv.ReadConfig(cfgPath, cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error reading config: %s", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "coin/cmd/app/config"
        hndl "coin/internal/api/http"
        "coin/internal/database/postgres"
        "coin/internal/database/redis"
        "coin/internal/repository"
        "coin/service"
        "database/sql"
        "fmt"
        "log"

        _ "github.com/lib/pq"

        "github.com/gin-gonic/gin"
)

const dbName = "coin"

func main() <span class="cov0" title="0">{
        appFlags := config.ParseFlags()
        var cfg config.AppConfig
        config.MustLoad(appFlags.ConfigPath, &amp;cfg)
        defaultDBConnStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=postgres sslmode=disable",
                cfg.BD.Host, cfg.BD.Port, cfg.BD.User, cfg.BD.Password)
        postgresDB, err := sql.Open("postgres", defaultDBConnStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("connection error to %s: %s", dbName, err)
        }</span>

        <span class="cov0" title="0">postgres.CreateCoinRepository("coin", postgresDB)
        coinDBConnStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                cfg.BD.Host, cfg.BD.Port, cfg.BD.User, cfg.BD.Password, dbName)
        coinDB, err := sql.Open("postgres", coinDBConnStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("connection error to %s: %s", "coin", err)
        }</span>

        <span class="cov0" title="0">postgres.InitCoinTables(coinDB)

        coinPG := postgres.NewPostgresStore(coinDB)
        log.Println(cfg.Redis.Addres)
        coinRdC := redis.NewRedisClient(cfg.Redis.Addres)
        coinRepo := repository.NewCoinRepository(coinPG, coinRdC)
        coinService := service.NewCoinService(coinRepo)
        coinHandler := hndl.NewCoinHandler(*coinService)

        r := gin.Default()
        coinHandler.WithObjectHandlers(r)

        log.Printf("Starting server on %s", cfg.HTTP.Address)
        if err := r.Run(cfg.HTTP.Address); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error run server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "coin/domain"
        mwAuth "coin/internal/api/http/middleware"
        auth "coin/internal/auth/jwt"
        "coin/service"
        "errors"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
)

type CoinHandler struct {
        service service.CoinService
}

func NewCoinHandler(service service.CoinService) *CoinHandler <span class="cov8" title="1">{
        return &amp;CoinHandler{
                service: service,
        }
}</span>

func (h *CoinHandler) Auth(c *gin.Context) <span class="cov0" title="0">{
        op := "http.coin.Auth"
        var rawUser domain.User
        if err := c.ShouldBindJSON(&amp;rawUser); err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Неверный запрос"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.service.GetUserByUsername(rawUser.Username)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not check user"})
                return
        }</span>

        <span class="cov0" title="0">token, err := auth.GenerateToken(user.Username)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
                return
        }</span>

        <span class="cov0" title="0">c.SetCookie("jwt_token", token, 3600, "/", "", false, true)

        c.JSON(http.StatusOK, gin.H{"token": token})</span>

}

func (h *CoinHandler) BuyItem(c *gin.Context) <span class="cov8" title="1">{
        op := "http.coin.BuyItem"
        username, ok := c.Get("username")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Ошибка авторизации"})
                return
        }</span>
        <span class="cov8" title="1">usernameStr, ok := username.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Println(op, "Error converting username")
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка преобразования имени пользователя"})
                return
        }</span>
        <span class="cov8" title="1">itemName := c.Param("item")
        if itemName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Имя товара обязательно"})
                return
        }</span>
        <span class="cov8" title="1">user, err := h.service.BuyItem(usernameStr, itemName)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrItemNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Такого товара нет"})
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, service.ErrCoinNotEnough) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Не достаточно койнов"})
                        return
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not buy item"})
                return</span>
        }
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"balance": user.Balance, "inventory": user.Inventory})</span>
}

func (h *CoinHandler) GetItems(c *gin.Context) <span class="cov0" title="0">{
        op := "http.coin.GetItems"
        items, err := h.service.GetItems()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal error"})
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, items)</span>
}

func (h *CoinHandler) Info(c *gin.Context) <span class="cov8" title="1">{
        op := "http.coin.Info"
        username, ok := c.Get("username")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Ошибка авторизации"})
                return
        }</span>
        <span class="cov8" title="1">usernameStr, ok := username.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Println(op, "Error converting username")
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка преобразования имени пользователя"})
                return
        }</span>
        <span class="cov8" title="1">user, err := h.service.GetUserByUsername(usernameStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not get user"})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "username":  username,
                "balance":   user.Balance,
                "inventory": user.Inventory,
        })</span>
}

func (h *CoinHandler) SendCoin(c *gin.Context) <span class="cov8" title="1">{
        op := "http.coin.SendCoin"
        var req struct {
                ToUser string `json:"to_user"`
                Amount int    `json:"amount"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Неверный запрос"})
                return
        }</span>
        <span class="cov8" title="1">if req.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Количетсво койнов должно быть больше 0"})
                return
        }</span>

        <span class="cov8" title="1">senderUsername, ok := c.Get("username")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Ошибка авторизации"})
                return
        }</span>
        <span class="cov8" title="1">senderUsernameStr, ok := senderUsername.(string)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка преобразования имени пользователя"})
                return
        }</span>

        <span class="cov8" title="1">if senderUsernameStr == req.ToUser </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Нельзя отправлять койны самому себе"})
                return
        }</span>

        <span class="cov8" title="1">balanceSender, err := h.service.SendCoin(senderUsernameStr, req.ToUser, req.Amount)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrCoinNotEnough) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Недостаточно койнов"})
                        return
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not send coin"})
                return</span>
        }
        <span class="cov8" title="1">log.Println(op, "Coin sent successfully")
        c.JSON(http.StatusOK, gin.H{
                "to_user":            req.ToUser,
                "amount":             req.Amount,
                "sender_new_balance": balanceSender,
        })</span>
}

func (h *CoinHandler) Operations(c *gin.Context) <span class="cov8" title="1">{
        const op = "http.coin.Operations"
        username, ok := c.Get("username")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Ошибка авторизации"})
                log.Println(op, "Error getting username from context")
                return
        }</span>
        <span class="cov8" title="1">usernameStr, ok := username.(string)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Ошибка преобразования имени пользователя"})
                return
        }</span>
        <span class="cov8" title="1">operations, err := h.service.GetOperations(usernameStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not get operations"})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, operations)
        log.Println(op, "Operations retrieved successfully")</span>

}

func (h *CoinHandler) WithObjectHandlers(r *gin.Engine) <span class="cov0" title="0">{
        r.Static("/static", "./static")
        r.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("./static")
        }</span>)
        <span class="cov0" title="0">api := r.Group("/api")
        </span><span class="cov0" title="0">{
                api.POST("/auth", h.Auth)
                api.GET("/info", mwAuth.AuthMiddleware, h.Info)
                api.POST("/sendCoin", mwAuth.AuthMiddleware, h.SendCoin)
                api.GET("/buy/:item", mwAuth.AuthMiddleware, h.BuyItem)
                api.GET("/items", h.GetItems)
                api.GET("/transactions", mwAuth.AuthMiddleware, h.Operations)
        }</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        auth "coin/internal/auth/jwt"
        "net/http"

        "github.com/gin-gonic/gin"
)

func AuthMiddleware(c *gin.Context) <span class="cov8" title="1">{
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Необходим токен"})
                c.Abort()
                return
        }</span>
        <span class="cov8" title="1">tokenString = tokenString[7:]
        claims, err := auth.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Неверный токен"})
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.Set("username", claims.Username)
        c.Next()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "errors"
        "time"

        jwt "github.com/dgrijalva/jwt-go"
)

var mySigningKey = []byte("supersecretkey")

type JwtClaim struct {
        Username string
        jwt.StandardClaims
}

func GenerateToken(username string) (string, error) <span class="cov8" title="1">{
        claims := &amp;JwtClaim{
                Username: username,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour * 24).Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString(mySigningKey)
}</span>

func ValidateToken(signedToken string) (*JwtClaim, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(
                signedToken,
                &amp;JwtClaim{},
                func(_ *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        return mySigningKey, nil
                }</span>,
        )

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*JwtClaim)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("неверный токен")
        }</span>

        <span class="cov8" title="1">if claims.ExpiresAt &lt; time.Now().Local().Unix() </span><span class="cov0" title="0">{
                return nil, errors.New("ожидался JWT")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package postgres

import (
        "coin/domain"
        "database/sql"
        "log"
        "time"
)

type preparedStatements struct {
        getUser       *sql.Stmt
        createUser    *sql.Stmt
        getOperations *sql.Stmt
}

type PostgresStore struct {
        DB    *sql.DB
        stmts *preparedStatements
}

func NewPostgresStore(db *sql.DB) *PostgresStore <span class="cov0" title="0">{
        InitCoinTables(db)
        stmts := newPreparedStatements(db)
        return &amp;PostgresStore{
                DB:    db,
                stmts: stmts,
        }
}</span>

func newPreparedStatements(db *sql.DB) *preparedStatements <span class="cov0" title="0">{
        const op = "database.postgres"
        stmts := &amp;preparedStatements{}
        var err error
        stmts.getUser, err = db.Prepare(`
                SELECT u.id, u.username, u.balance, i.item_type, i.quantity 
                FROM users u
                LEFT JOIN inventory_items i on u.id=i.user_id
                WHERE u.username=$1;
        `)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
        }</span>

        <span class="cov0" title="0">stmts.createUser, err = db.Prepare(`
                INSERT INTO users (username, balance)
                VALUES ($1, $2);
        `)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
        }</span>

        <span class="cov0" title="0">stmts.getOperations, err = db.Prepare(`
                SELECT t.from_user, t.to_user, t.amount, t.created_at
                FROM transactions t
                JOIN users u1 ON t.from_user = u1.username
                JOIN users u2 ON t.to_user = u2.username
                WHERE t.from_user = $1 OR t.to_user = $1
                ORDER BY t.created_at DESC
        `)

        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
        }</span>

        <span class="cov0" title="0">return stmts</span>

}

func (r *PostgresStore) GetUser(username string) (domain.User, error) <span class="cov0" title="0">{
        var u domain.User
        var itemType sql.NullString
        var itemQuantity sql.NullInt64
        u.Inventory = make([]domain.InventoryItem, 0)
        rows, err := r.stmts.getUser.Query(username)
        if err != nil </span><span class="cov0" title="0">{
                return domain.User{}, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(&amp;u.ID, &amp;u.Username, &amp;u.Balance, &amp;itemType, &amp;itemQuantity); err != nil </span><span class="cov0" title="0">{
                        return domain.User{}, err
                }</span>
                <span class="cov0" title="0">if itemType.Valid &amp;&amp; itemQuantity.Valid </span><span class="cov0" title="0">{
                        u.Inventory = append(u.Inventory, domain.InventoryItem{ItemType: itemType.String, Quantity: int(itemQuantity.Int64)})
                }</span>
        }
        <span class="cov0" title="0">return u, nil</span>
}

func (r *PostgresStore) CreateUser(username string, balance int) error <span class="cov0" title="0">{
        _, err := r.stmts.createUser.Exec(username, balance)
        return err
}</span>

func (r *PostgresStore) PostBuyItem(userID uint, itemName string, price int) error <span class="cov0" title="0">{
        const op = "database.postgres.PostBuyItem"
        tx, err := r.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(`
        UPDATE users SET balance = balance - $1 WHERE id = $2;`,
                price, userID)
        if err != nil </span><span class="cov0" title="0">{
                err2 := tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        log.Println(op, err2)
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                return err</span>
        }
        <span class="cov0" title="0">stmt := `INSERT INTO inventory_items (user_id, item_type, quantity)
                VALUES ($1, $2, 1)
                ON CONFLICT (user_id, item_type)
                DO UPDATE SET quantity = inventory_items.quantity + EXCLUDED.quantity;`

        _, err = tx.Exec(stmt, userID, itemName)
        if err != nil </span><span class="cov0" title="0">{
                err2 := tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        log.Println(op, err2)
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                return err</span>
        }
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *PostgresStore) GetOperations(username string) ([]domain.Operations, error) <span class="cov0" title="0">{
        const op = "database.postgres.GetOperations"
        rows, err := r.stmts.getOperations.Query(username)
        operations := make([]domain.Operations, 0)
        if err != nil </span><span class="cov0" title="0">{
                return []domain.Operations{}, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var t domain.Operations
                err := rows.Scan(&amp;t.FromUser, &amp;t.ToUser, &amp;t.Amount, &amp;t.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(op, err)
                        continue</span>
                }
                <span class="cov0" title="0">operations = append(operations, t)</span>
        }
        <span class="cov0" title="0">return operations, nil</span>
}

func (r *PostgresStore) SendCoinTransaction(senderUsername, recipientUsername string, amount int) error <span class="cov0" title="0">{
        const op = "database.postgres.SendCoinTransaction"
        tx, err := r.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE users SET balance = balance - $1 WHERE username = $2;`,
                amount, senderUsername)
        if err != nil </span><span class="cov0" title="0">{
                err2 := tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        log.Println(op, err2)
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                return err</span>
        }

        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE users SET balance = balance + $1 WHERE username = $2;
        `, amount, recipientUsername)
        if err != nil </span><span class="cov0" title="0">{
                err2 := tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        log.Println(op, err2)
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                return err</span>
        }
        <span class="cov0" title="0">log.Printf("from_user = %s", senderUsername)
        _, err = tx.Exec(`INSERT INTO transactions (from_user, to_user, amount, created_at) VALUES ($1, $2, $3, $4)`,
                senderUsername, recipientUsername, amount, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                err2 := tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        log.Println(op, err2)
                }</span>
                <span class="cov0" title="0">log.Println(op, err)
                return err</span>
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package postgres

import (
        "database/sql"
        "log"

        _ "github.com/lib/pq" // postgres driver
)

func CreateCoinRepository(dbName string, db *sql.DB) <span class="cov0" title="0">{
        var exists bool
        query := `SELECT EXISTS (SELECT 1 FROM pg_database WHERE datname = $1)`
        if err := db.QueryRow(query, dbName).Scan(&amp;exists); err != nil </span><span class="cov0" title="0">{
                log.Fatal("error checking the existence of the database", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                log.Printf("DB %q already exists\n", dbName)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Creating a database %q\n", dbName)
                _, err := db.Exec("CREATE DATABASE " + dbName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("error when creating the database\n", err)
                }</span>
                <span class="cov0" title="0">log.Printf("database %q was created successfully\n", dbName)</span>
        }
}

func InitCoinTables(db *sql.DB) <span class="cov0" title="0">{
        const op = "database.postgres.InitCoinTables"
        _, err := db.Exec(`
                CREATE TABLE IF NOT EXISTS items (
                        name varchar PRIMARY KEY,
                        price INT NOT NULL
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS users (
                        id SERIAL PRIMARY KEY,
                        username VARCHAR(255) UNIQUE NOT NULL,
                        balance INT NOT NULL DEFAULT 1000)`)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS transactions (
                        id SERIAL PRIMARY KEY,
                        from_user VARCHAR(255) REFERENCES users(username),
                        to_user VARCHAR(255) REFERENCES users(username),
                        amount INT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS inventory_items (
                        id SERIAL PRIMARY KEY,
                        user_id INT REFERENCES users(id),
                        item_type VARCHAR(255) NOT NULL,
                        quantity INT NOT NULL DEFAULT 0);`)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE UNIQUE INDEX IF NOT EXISTS idx_inventory_unique
                ON inventory_items (user_id, item_type);
        `)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE UNIQUE INDEX IF NOT EXISTS idx_name_item_unique
                ON items(name);
        `)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>

        <span class="cov0" title="0">log.Println("all tables are filled in")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package redis

import (
        "bufio"
        "coin/domain"
        "context"
        "log"
        "os"
        "strconv"
        "strings"

        "github.com/redis/go-redis/v9"
)

var ctx = context.Background()

type RedisClient struct {
        Client *redis.Client
}

func NewRedisClient(addr string) *RedisClient <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr: addr,
        })
        _, err := rdb.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to Redis: %v", err)
        }</span>
        <span class="cov0" title="0">redis := &amp;RedisClient{Client: rdb}
        if err = redis.insertItems(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to fill redis")
        }</span>
        <span class="cov0" title="0">return redis</span>
}

func (r *RedisClient) insertItems() error <span class="cov0" title="0">{
        const op = "database.redis.insertItems"
        log.Println(op, "attempting to read items.csv")
        file, err := os.Open("items.csv")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(op, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                fields := strings.Split(scanner.Text(), ",")
                log.Println(op, "parsed line:", fields)

                err := r.Client.HSet(ctx, "item:"+fields[0], map[string]interface{}{
                        "price": fields[1],
                }).Err()
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(op, err)
                        continue</span>
                }
                <span class="cov0" title="0">log.Println(op, "successfully set item:", fields[0])</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *RedisClient) GetItemPrice(itemName string) (int, error) <span class="cov0" title="0">{
        priceStr, err := r.Client.HGet(ctx, "item:"+itemName, "price").Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">price, err := strconv.Atoi(priceStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return price, nil</span>
}

func (r *RedisClient) GetItems() ([]domain.Item, error) <span class="cov0" title="0">{
        var cursor uint64
        var items []domain.Item

        for </span><span class="cov0" title="0">{
                keys, newCursor, err := r.Client.Scan(ctx, cursor, "item:*", 10).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">cursor = newCursor

                for _, key := range keys </span><span class="cov0" title="0">{
                        data, err := r.Client.HGetAll(ctx, key).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("HGetAll error:", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">price, err := strconv.Atoi(data["price"])
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("Invalid price for key", key)
                                continue</span>
                        }

                        <span class="cov0" title="0">parts := strings.SplitN(key, "item:", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                log.Println("Invalid key format:", key)
                                continue</span>
                        }

                        <span class="cov0" title="0">item := domain.Item{
                                Name:  parts[1],
                                Price: price,
                        }
                        items = append(items, item)</span>
                }

                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "coin/domain"
        "coin/internal/database/postgres"
        "coin/internal/database/redis"
)

type CoinRepository struct {
        Postgres *postgres.PostgresStore
        Redis    *redis.RedisClient
}

func NewCoinRepository(pg *postgres.PostgresStore, rds *redis.RedisClient) *CoinRepository <span class="cov0" title="0">{
        return &amp;CoinRepository{
                Postgres: pg,
                Redis:    rds,
        }
}</span>

func (r *CoinRepository) CreateUser(username string, balance int) error <span class="cov0" title="0">{
        return r.Postgres.CreateUser(username, balance)
}</span>

func (r *CoinRepository) GetUser(username string) (domain.User, error) <span class="cov0" title="0">{
        return r.Postgres.GetUser(username)
}</span>

func (r *CoinRepository) SendCoinTransaction(senderUsername, recipientUsername string, amount int) error <span class="cov0" title="0">{
        return r.Postgres.SendCoinTransaction(senderUsername, recipientUsername, amount)
}</span>

func (r *CoinRepository) PostBuyItem(userID uint, itemName string) error <span class="cov0" title="0">{
        price, err := r.Redis.GetItemPrice(itemName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return r.Postgres.PostBuyItem(userID, itemName, price)</span>
}

func (r *CoinRepository) GetOperations(username string) ([]domain.Operations, error) <span class="cov0" title="0">{
        return r.Postgres.GetOperations(username)
}</span>

func (r *CoinRepository) GetItems() ([]domain.Item, error) <span class="cov0" title="0">{
        return r.Redis.GetItems()
}</span>

func (r *CoinRepository) GetItemPrice(itemName string) (int, error) <span class="cov0" title="0">{
        return r.Redis.GetItemPrice(itemName)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package mocks

import (
        "coin/domain"
        "errors"
        "time"
)

type InMemoryRepo struct {
        Users         map[string]domain.User
        ItemPrices    map[string]int
        Items         []domain.Item
        Ops           map[string][]domain.Operations
        autoIncUserID uint
}

func NewInMemoryRepo() *InMemoryRepo <span class="cov8" title="1">{
        return &amp;InMemoryRepo{
                Users:      make(map[string]domain.User),
                ItemPrices: map[string]int{"sword": 100, "shield": 150},
                Items: []domain.Item{
                        {Name: "sword", Price: 100},
                        {Name: "shield", Price: 150},
                },
                Ops:           make(map[string][]domain.Operations),
                autoIncUserID: 1,
        }
}</span>

func (m *InMemoryRepo) GetUser(username string) (domain.User, error) <span class="cov8" title="1">{
        user, ok := m.Users[username]
        if !ok </span><span class="cov8" title="1">{
                return domain.User{}, nil
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (m *InMemoryRepo) CreateUser(username string, balance int) error <span class="cov8" title="1">{
        m.Users[username] = domain.User{
                ID:       m.autoIncUserID,
                Username: username,
                Balance:  balance,
        }
        m.autoIncUserID++
        return nil
}</span>

func (m *InMemoryRepo) PostBuyItem(userID uint, itemName string) error <span class="cov8" title="1">{
        for username, user := range m.Users </span><span class="cov8" title="1">{
                if user.ID == userID </span><span class="cov8" title="1">{
                        user.Inventory = append(user.Inventory, domain.InventoryItem{ItemType: itemName, Quantity: 1})
                        user.Balance -= m.ItemPrices[itemName]
                        m.Users[username] = user
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return errors.New("user not found")</span>
}

func (m *InMemoryRepo) GetItems() ([]domain.Item, error) <span class="cov8" title="1">{
        return m.Items, nil
}</span>

func (m *InMemoryRepo) GetItemPrice(itemName string) (int, error) <span class="cov8" title="1">{
        return m.ItemPrices[itemName], nil
}</span>

func (m *InMemoryRepo) GetOperations(username string) ([]domain.Operations, error) <span class="cov8" title="1">{
        return m.Ops[username], nil
}</span>

func (m *InMemoryRepo) SendCoinTransaction(senderUsername, recipientUsername string, amount int) error <span class="cov8" title="1">{
        sender := m.Users[senderUsername]
        recipient := m.Users[recipientUsername]

        sender.Balance -= amount
        recipient.Balance += amount

        m.Users[senderUsername] = sender
        m.Users[recipientUsername] = recipient

        m.Ops[senderUsername] = append(m.Ops[senderUsername], domain.Operations{
                FromUser:  sender.Username,
                ToUser:    recipient.Username,
                Amount:    -amount,
                CreatedAt: time.Now(),
        })
        m.Ops[recipientUsername] = append(m.Ops[recipientUsername], domain.Operations{
                FromUser:  sender.Username,
                ToUser:    recipient.Username,
                Amount:    amount,
                CreatedAt: time.Now(),
        })
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package service

import (
        "coin/domain"
        "coin/internal/repository"
        "log"
)

type CoinService struct {
        repo repository.Object
}

func NewCoinService(repo repository.Object) *CoinService <span class="cov8" title="1">{
        return &amp;CoinService{
                repo: repo,
        }
}</span>

const DefaultBalance = 1000

func (s *CoinService) GetUserByUsername(username string) (domain.User, error) <span class="cov8" title="1">{
        const op = "service.coin.GetUserByUsername"
        user, err := s.repo.GetUser(username)
        if err != nil </span><span class="cov0" title="0">{
                return domain.User{}, err
        }</span>
        <span class="cov8" title="1">if user.ID == 0 &amp;&amp; user.Username == "" &amp;&amp; user.Balance == 0 &amp;&amp; len(user.Inventory) == 0 </span><span class="cov8" title="1">{
                err = s.СreateUser(username)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(op, err)
                        return domain.User{}, err
                }</span>
                <span class="cov8" title="1">user, err = s.repo.GetUser(username)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(op, err)
                        return domain.User{}, err
                }</span>
        }
        <span class="cov8" title="1">return user, nil</span>
}

func (s *CoinService) СreateUser(username string) error <span class="cov8" title="1">{
        const op = "service.coin.createUser"
        err := s.repo.CreateUser(username, DefaultBalance)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return err
        }</span>
        <span class="cov8" title="1">_, err = s.GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *CoinService) BuyItem(username string, itemName string) (domain.User, error) <span class="cov8" title="1">{
        const op = "service.coin.BuyItem"
        price, err := s.repo.GetItemPrice(itemName)
        if err != nil </span><span class="cov0" title="0">{
                return domain.User{}, ErrItemNotFound
        }</span>

        <span class="cov8" title="1">user, err := s.GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return domain.User{}, err
        }</span>
        <span class="cov8" title="1">if user.Balance &lt; price </span><span class="cov8" title="1">{
                return domain.User{}, ErrCoinNotEnough
        }</span>
        <span class="cov8" title="1">user.Balance -= price
        err = s.repo.PostBuyItem(user.ID, itemName)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return domain.User{}, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (s *CoinService) GetItems() ([]domain.Item, error) <span class="cov8" title="1">{
        return s.repo.GetItems()
}</span>

func (s *CoinService) SendCoin(senderUsername string, recipientUsername string, amount int) (int, error) <span class="cov8" title="1">{
        const op = "service.coin.SendCoin"
        sender, err := s.GetUserByUsername(senderUsername)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return sender.Balance, err
        }</span>
        <span class="cov8" title="1">log.Println(senderUsername, recipientUsername)
        recipient, err := s.GetUserByUsername(recipientUsername)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return sender.Balance, err
        }</span>

        <span class="cov8" title="1">if sender.Balance &lt;= 0 </span><span class="cov0" title="0">{
                return sender.Balance, ErrCoinNotEnough
        }</span>

        <span class="cov8" title="1">if sender.Balance &lt; amount </span><span class="cov0" title="0">{
                return sender.Balance, ErrCoinNotEnough
        }</span>
        <span class="cov8" title="1">err = s.repo.SendCoinTransaction(sender.Username, recipient.Username, amount)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return sender.Balance, err
        }</span>
        <span class="cov8" title="1">return sender.Balance - amount, nil</span>
}

func (s *CoinService) GetOperations(username string) ([]domain.Operations, error) <span class="cov8" title="1">{
        const op = "service.coin.GetOperations"
        user, err := s.GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return nil, err
        }</span>
        <span class="cov8" title="1">operations, err := s.repo.GetOperations(user.Username)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(op, err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return operations, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
